# How to create new cargo
cargo new hello_cargo

# Run your code cargo
./target/debug/hello_cargo

# Cargo summary
We can build a project using cargo build.
We can build and run a project in one step using cargo run.
We can build a project without producing a binary to check for errors using cargo check.
Instead of saving the result of the build in the same directory as our code, Cargo stores it in the target/debug directory.

# bringing library
use std::io;
"By default, Rust has a few items defined in the standard library that it brings into the scope
of every program. This set is called the prelude, and you can see everything in it in the standard library documentation.
If a type you want to use isn’t in the prelude, you have to bring that type into scope explicitly
with a use statement. Using the std::io library provides you with a number of useful features, including the ability to accept user input."


# mutable variabel
let mut guess = String::new(); # this is mutable
let fruit = "Apple" # this isn't mutable, like const on javascript

# note about std::io::stdin
If we hadn’t imported the io library with use std::io
at the beginning of the program, we could still use the
function by writing this function call as std::io::stdin
The stdin function returns an instance of std::io::Stdin,
which is a type that represents a handle to the standard
input for your terminal.

# calling method
.method_name()